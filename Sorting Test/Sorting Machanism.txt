* 선형정렬 3종 구현 원리

1. 선택 정렬
선택 정렬은 배열의 인덱스들을 하나하나 살펴본 뒤 가장 작은 값을 맨 앞의 인덱스로 보내는 방법이다.
배열을 처음부터 끝까지 탐색한 뒤에 제일 작은 인덱스를 발견하면, 그 인덱스를 선택하여 저장하고 맨 앞의 인덱스와 Swap하고
두 번째 인덱스도 동일한 방법으로 Swap하면서 정렬을하게 된다.

2. 삽입 정렬
삽입 정렬은 배열을 처음부터 끝까지 탐색하면서 만약 정렬 되지 않은 값이 있을 경우 해당 값을 배열의 알맞은 위치에 삽입하는 방식이다.
삽입을 진행하기 위해 선택된 값은 외부에 저장해 놓고 알맞은 위치부터 선택된 값까지의 인덱스를 한칸 뒤로 밀어 공간을 확보한 후
저장한 값을 지정된 위치에 덮어씌워 주는 원리이다.
하지만 배열에서는 중간에 끼워넣는다는 개념은 없으므로, 지정한 값을 앞으로 한칸씩 옮겨가면서 원하는 위치에 끼워넣는 방식으로 동작한다.

3. 버블 정렬
버블 정렬은 인접한 인덱스 두개를 비교하여 작은 것을 왼쪽 큰것을 오른쪽에 배치하는 방식이다.
인접한 두개의 인덱스가 왼쪽이 큰값, 오른쪽이 작은 값이라면, 해당 인덱스들을 서로 Swap해 주고 반대의 경우라면 다음 인덱스로 넘어가게 된다.
해당 동작을 반복해주면, 앞의 두 정렬과는 다르게 버블 정렬은 앞에서 부터 작은 값이 아닌 뒤에서 부터 큰 값이 들어가게 된다.


* 분할정복정렬 3종 구현 원리

1. 힙 정렬
힙 정렬은 힙(우선순위 큐) 자료구조를 사용한 정렬이다.
힙은 우선순위가 빠른 것 즉, 숫자가 작은 것 부터 인덱스에 저장하게 되므로, 데이터의 값과 우선순위를 같은 값으로 설정해주게 되면
데이터를 힙에 저장할 때 자동으로 정렬을 만들어주게 된다.(오름차순 기준 최소힙)
힙은 트리기반의 자료구조이기 때문에 이분할로 데이터들을 탐색하게 되며, 이 때 시간 복잡도는 O(nlogn) 이다.

2. 병합 정렬
병합 정렬은 들어온 데이터를 반으로 나누는 작업을 반복하면서 나눌 수 있는 최소 크기로 나눠준 후 다시 병합하는 과정을 거치면서 정렬하는 방법이다.
병합 정렬에는 분할정복 알고리즘이 사용되며, 최소 크기로 나눠진 데이터를 다시 병합하는 과정에서 더 작은 값은 왼쪽으로 큰값은 오른쪽으로 병합을 진행한다.
해당 과정은 원래의 배열 크기가 될 때까지 진행하게 된다.
이러한 병합 과정에서 데이터들을 절반씩 나누어 비교하기 때문에 시간 복잡도 상에서 유리하게 된다.

3. 퀵 정렬
퀵 정렬은 기준이 되는 피벗을 하나 설정한 뒤 그 피벗을 기준으로 피벗보다 작은 값은 왼쪽, 피벗보다 큰 값은 오른쪽에 배치하여 정렬하는 방법이다.
배열을 순회하는 i와 j를 설정하여 i는 0번부터 end까지 j는 end부터 0번까지 순회하면서 서로 엇갈리게 될 경우 배치가 끝난것으로 간주한다.
만약 피벗 기준 왼쪽과 오른쪽의 배치가 끝났다면, 다른 피벗을 기준으로 잡고 정렬을 진행하게 되며, 
만약 처음의 0번 인덱스가 end인덱스와 엇갈렸다면 피벗을 한번씩 설정해서 분할 했다는 의미이므로 정렬을 종료하게된다.

* 분할정복정렬 3종의 원리에 의한 특징(힙정렬, 병합정렬, 퀵정렬)

- 합병 정렬의 경우 반절의 데이터를 다른곳에 저장할 공간이 새로 필요함 즉, 새로운 배열을 복사해서 할당하여 사용하게됨
따라서 메모리 측면에서 효율적인 정렬은 아니다. 따라서 메모리를 아껴야하거나 성능이 좋지않은 기기에서 게임을 돌려야한다면
합병 정렬은 어울리지 않을 수 있음

- 퀵정렬은 Swap하는 방식이므로 추가적인 메모리 사용은 하지 않음 
하지만, 최악의 경우 정렬 시간이 n^2으로, 상황에 따라 조심해야할 필요가 있음
만약 데이터가 역순 정렬이 되어있거나 피벗이 한쪽에 다 몰려있는 상황이라면 버블정렬이랑 시간복잡도가 다를게 없어진다.
분산이 잘 되어있는 데이터들을 정렬할때는 조금 낫지만, 역순 정렬 등 한번 가공한 데이터일 경우 조심해야한다.
또한 퀵정렬은 불안정성이 높은 정렬이다.

- 힙정렬은 안정성측면에서 떨어지는 감이 있다.
안정성이 떨어진다는 의미는 예를 들어 같은 값의 데이터가 존재할 때 해당 데이터가 숫자만 같고 다른 객체를 나타내는 경우
정렬을 진행했을 때 원래 데이터의 위치와 정렬된 데이터의 위치가 서로 뒤바뀌는 상황이 발생할 수 있다.
즉, 동일한 데이터에 대해 동일한 정렬 위치를 보장해 주지 않으므로, 상황을 탈 수 있다.

- 합병 정렬이나 퀵정렬의 경우 배열 기반의 정렬이다. 따라서 캐시메모리가 사용하기에 편하고 정렬을 빠르게 진행할 수 있다.
그에 반해 힙정렬의 경우 연속된 배열 기반 정렬이긴 하지만, 트리기반의 자료구조이기 때문에 인덱스로의 접근이 일반적인 배열과는 다르다.
이는 캐시 메모리에 배열을 두 세번 불러와야하는 경우가 생길 수 있으며, 이때문에 힙정렬이 퀵, 병합정렬보다 느리게 된다.
정리하면 힙 정렬은 어떠한 처리를 하기 위해 들어가는 간접적인 처리 시간 즉, 오버헤드가 있을 수 있기 때문에 속도가 느린것

3가지의 정렬이 모두 장단이 확실하기 때문에 정렬을 사용할 때에는 상황에 맞게 활용할 수 있어야한다.

즉,
1. 데이터의 분산이 잘 되어있는데, 메모리는 빡빡하며 가공되지 않은 데이터의 경우 퀵정렬
2. 데이터의 중복이 많으며, 메모리에 여유가 있는 경우 합병 정렬
3. 메모리는 빡빡하고 데이터는 가공되어 있으며, 데이터의 중복이 많지 않은 경우에는 힙정렬
정도로 정리할 수 있다.